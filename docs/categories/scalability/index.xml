<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>scalability on Jos de Jong</title>
    <link>https://josdejong.com/categories/scalability/</link>
    <description>Recent content in scalability on Jos de Jong</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright &amp;copy; 2013-2020 &lt;a href=&#39;https://josdejong.com&#39;&gt;Jos de Jong&lt;/a&gt; &amp;bull; powered by &lt;a href=&#39;https://gohugo.io/&#39;&gt;Hugo&lt;/a&gt; and &lt;a href=&#39;https://pages.github.com/&#39;&gt;GitHub pages&lt;/a&gt; &amp;bull; background from &lt;a href=&#39;https://www.technobuffalo.com/sites/technobuffalo.com/files/wp/2010/11/tb-wallpaper-blue-2560x1440.jpg&#39;&gt;technobuffalo&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 05 Jun 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://josdejong.com/categories/scalability/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Static typing: the good parts</title>
      <link>https://josdejong.com/blog/2016/06/05/static-typing-the-good-parts/</link>
      <pubDate>Sun, 05 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://josdejong.com/blog/2016/06/05/static-typing-the-good-parts/</guid>
      <description>tl;dr So far I&amp;rsquo;ve been hesitant to embrace static type checkers like TypeScript. It&amp;rsquo;s because I associated static type checking with the restrictions and interoperability issues that I know from Java and C++. However, it turns out that TypeScript is different: it uses a structural type system rather than a nominal one, which eliminates these downsides. It gives us a way to describe data types without sacrificing flexibility, interoperability, or scalability.</description>
    </item>
    
  </channel>
</rss>